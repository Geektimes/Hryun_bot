--- D:\Projects\Hryun_bot\bot.py ---
# bot.py
import asyncio
from aiogram import Bot, Dispatcher
from database import init_db
from middlewares.db import DBSessionMiddleware
from middlewares.rate_limit import RateLimitMiddleware
import logging
from logging.handlers import RotatingFileHandler
import os

from handlers.basic_handlers import rate_limited_router, router
from config import load_config

config = load_config()

bot = Bot(config.TOKEN)
dp = Dispatcher(unfiltered=True)

# Настройка логирования
log_dir = "logs"
if not os.path.exists(log_dir):
    os.makedirs(log_dir)
log_file = os.path.join(log_dir, "bot.log")
log_format = "%(asctime)s - %(levelname)s - %(name)s - %(message)s"

log_handler = RotatingFileHandler(
    log_file,
    maxBytes=5 * 1024 * 1024,
    backupCount=5,
    encoding="utf-8",
    delay=False
)

logging.basicConfig(
    level=logging.INFO,
    format=log_format,
    handlers=[
        log_handler,
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


async def main():
    logger.info("Запуск бота...")
    await init_db()

    # Регистрируем middlewares
    dp.update.middleware(DBSessionMiddleware())
    rate_limited_router.message.middleware(RateLimitMiddleware(limit=1, period=5))

    # Регистрируем роутеры
    dp.include_router(rate_limited_router)
    dp.include_router(router)

    await bot.delete_webhook(drop_pending_updates=True)
    logger.info("Бот успешно запущен, начинаем polling")
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())


----------------------------------------

--- D:\Projects\Hryun_bot\config.py ---
#config.py
import os
from dataclasses import dataclass
import yaml
from dotenv import load_dotenv

load_dotenv()

with open("config.yaml", "r", encoding="utf-8") as f:
    config = yaml.safe_load(f)

@dataclass
class Config:
    API_KEY: str = os.getenv('API_KEY')
    API_URL: str = os.getenv('API_URL')
    TOKEN: str = os.getenv('BOT_TOKEN')
    DB_NAME = os.getenv('DB_NAME')
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))
    DB_PATH = os.path.join(BASE_DIR, DB_NAME)
    BOT_USERNAME: str = os.getenv('BOT_USERNAME')
    BOT_NAME: str = os.getenv('BOT_NAME')
    BOT_LAST_NAME: str = os.getenv('BOT_LAST_NAME')
    BOT_TG_ID: int = os.getenv('BOT_TG_ID')
    SRC_PATH: str = os.path.join(BASE_DIR, "source")
    ANEKDOTS_FILE: str = os.path.join(BASE_DIR, "source", "anekdots.yaml")
    GREETING: str = config["GREETING"]
    SUMMARY_PROMPT = config["SUMMARY_PROMPT"]
    HRYUN_PROMPT = config["HRYUN_PROMPT"]

    MODEL_GEMINI_PRO_2_5 = "google/gemini-2.5-pro-exp-03-25:free"
    MODEL_DEEPSEEK_V3 = "deepseek/deepseek-v3-base:free"
    MODEL_QWEN_2_5 = "qwen/qwen2.5-vl-32b-instruct:free"
    MODEL_GEMMA_3_27B = "google/gemma-3-27b-it:free"
    MODEL_MISTRAL_SMALL_3_1 = "mistralai/mistral-small-3.1-24b-instruct:free"


def load_config():
    return Config()


----------------------------------------

--- D:\Projects\Hryun_bot\database.py ---
# database.py
import os
from sqlalchemy import create_engine, Column, Integer, String, DateTime, ForeignKey, Table, Boolean
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import declarative_base, sessionmaker, relationship
from datetime import datetime
from contextlib import asynccontextmanager

from config import load_config

config = load_config()

# Создаем подключение к SQLite
file_path = config.DB_PATH
DATABASE_URL = f"sqlite+aiosqlite:///{file_path}"

# Создаем таблицы в базе данных
async def init_db():
    if not os.path.exists(file_path):
        print(f"База данных {file_path} не найдена. Создаем новую...")
        async with engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all)
        print("База данных успешно создана.")
    else:
        print(f"База данных {file_path} уже существует.")


# Асинхронный контекстный менеджер для сессий
@asynccontextmanager
async def get_db():
    async with AsyncSessionLocal() as session:
        yield session


engine = create_async_engine(DATABASE_URL, echo=False)
AsyncSessionLocal = async_sessionmaker(bind=engine, expire_on_commit=False)

Base = declarative_base()

# Промежуточная таблица для связи многие-ко-многим между пользователями и чатами
user_chat_association = Table(
    "user_chat_association",
    Base.metadata,
    Column("user_id", Integer, ForeignKey("users.id"), primary_key=True),
    Column("chat_id", Integer, ForeignKey("chats.id"), primary_key=True),
)


class Message(Base):
    __tablename__ = "messages"

    id = Column(Integer, primary_key=True, autoincrement=True)
    tg_message_id = Column(Integer, nullable=False)
    chat_id = Column(Integer, ForeignKey("chats.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    content = Column(String, nullable=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    reply_to_tg_message_id = Column(Integer, ForeignKey("messages.tg_message_id"), nullable=True)
    bot_addressed = Column(Boolean, default=False, nullable=False)
    type = Column(String, nullable=False)

    # Связи
    chat = relationship("Chat", back_populates="messages")
    user = relationship("User", back_populates="messages")
    reply_to_message = relationship("Message", remote_side=[tg_message_id], backref="replies")


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, autoincrement=True)
    tg_username = Column(String, nullable=True)
    tg_first_name = Column(String, nullable=False)
    tg_last_name = Column(String, nullable=True)
    tg_user_id = Column(Integer, nullable=True)
    is_bot = Column(Boolean, default=False, nullable=False)

    # Связи
    chats = relationship("Chat", secondary=user_chat_association, back_populates="users")
    messages = relationship("Message", back_populates="user")


# Модель чатов
class Chat(Base):
    __tablename__ = "chats"

    id = Column(Integer, primary_key=True, autoincrement=True)
    tg_chat_id = Column(Integer, nullable=True)
    title = Column(String, nullable=True)

    # Связи
    users = relationship("User", secondary=user_chat_association, back_populates="chats")
    messages = relationship("Message", back_populates="chat")


class UsedAnekdot(Base):
    __tablename__ = "used_anekdots"
    anekdot_key = Column(String, primary_key=True, index=True)


----------------------------------------

--- D:\Projects\Hryun_bot\README.md ---
# Hryun_bot
бот с ИИ "Хрюн Моржов"

----------------------------------------

--- D:\Projects\Hryun_bot\handlers\basic_handlers.py ---
# handlers\basic_handlers.py
import re
import logging
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from aiogram.types import Message
from sqlalchemy.orm import Session
from colorama import init, Fore
from functools import wraps

from utils.services import save_message, get_anekdot
from utils.history_listing import get_history_listing
from config import load_config
from utils.AI import LLM
from database import User, Chat, Message, get_db
from utils.message_thread import get_message_thread
from utils.lock import ChatLocks

config = load_config()

# rate_limit = RateLimitMiddleware(limit=1, period=10)

llm = LLM()

rate_limited_router = Router()
router = Router()


@router.message(CommandStart())
async def start_handler(message: types.Message):
    logging.info(f"Команда /start от пользователя {message.from_user.id} в чате {message.chat.id}")

    # Сохраняем сообщение, при этом явно указываем, что бот был адресован
    await save_message(message, bot_addressed=True)

    await message.answer(config.GREETING)


@router.message(Command("help"))
async def help_handler(message: types.Message):
    await message.answer("Доступные команды:\n/start — начать\n/help — помощь \nНаписать разработчику - @WEB3_0_master")


@rate_limited_router.message(Command("anekdot"))
async def send_anekdot_handler(message: Message):
    # Сохраняем сообщение пользователя в базу
    await save_message(message, bot_addressed=True)
    anekdot = await get_anekdot()
    if anekdot:  # Если ответ получен
        bot_message = await message.answer(anekdot)
        await save_message(bot_message, bot_addressed=True)


@router.message(lambda msg: msg.text and msg.text.strip().lower() == "хрюн анекдот")
async def anekdot_handler(message: Message):
    # Сохраняем сообщение пользователя в базу
    await save_message(message, bot_addressed=True)
    anekdot = await get_anekdot()
    if anekdot:  # Если ответ получен
        bot_message = await message.answer(anekdot)
        await save_message(bot_message, bot_addressed=True)


# 1. Ответ в личке
@router.message(F.chat.type == "private", F.text)
async def private_chat_handler(message: Message):
    logging.info(f"Сообщение в личке {message.chat.id} от {message.from_user.id}: {Fore.WHITE}{message.text}")
    await save_message(message, bot_addressed=True)
    role = 'assistant' if message.text.lower().startswith('хрюш') else 'hryn'
    bot_text = llm.ask(message.text, role=role)
    if bot_text:
        bot_message = await message.answer(bot_text)
        await save_message(bot_message, bot_addressed=True)


@router.message(lambda msg: msg.text and msg.text.lower().startswith("отчет"))
async def report_handler(message: Message):
    chat_lock = ChatLocks.get_lock(message.chat.id)

    if chat_lock.locked():
        # await message.answer("Подождите, предыдущий отчет еще формируется...")
        return

    async with chat_lock:
        try:
            match = re.match(r'^отчет\s+([1-9][0-9]{0,2})$', message.text.lower())
            if match:
                limit = min(int(match.group(1)), 200)
            else:
                limit = 100

            history_listing = await get_history_listing(message.chat.id, limit=limit)

            logging.info(f"Отчет для чата {message.chat.id}:\n{history_listing}")
            bot_text = llm.ask(history_listing, role='summary')

            if bot_text:
                await message.answer(bot_text, reply_to_message_id=message.message_id)
        except Exception as e:
            logging.error(f"Ошибка при формировании отчета: {e}")
            await message.answer("Произошла ошибка при формировании отчета")


# Обработка "хрюша ..."
@router.message(lambda msg: msg.text and msg.text.lower().startswith("хрюша"))
async def assistant_handler(message: Message):
    logging.info(f"Сообщение в группе для 'хрюша' {message.chat.id} от {message.from_user.id}: {Fore.WHITE}{message.text}")
    await save_message(message, bot_addressed=True)
    bot_text = llm.ask(message.text, role="assistant")
    if bot_text:
        bot_message = await message.answer(bot_text, reply_to_message_id=message.message_id)
        await save_message(bot_message, bot_addressed=True)


# Обработка упоминания бота или "хрюн ..."
@router.message(lambda msg: msg.text and (
    (msg.reply_to_message and msg.reply_to_message.from_user.is_bot)  # Ответ на сообщение бота
    or msg.text.lower().startswith("хрюн")
))
async def mention_handler(message: Message):
    logging.info(
        f"Сообщение в группе для 'хрюн' {message.chat.id} от {message.from_user.id}: {Fore.WHITE}{message.text}")


    async with get_db() as db:
        context = await get_message_thread(db=db, tg_user_id=message.from_user.id, tg_chat_id=message.chat.id)

    await save_message(message, bot_addressed=True)

    bot_text = llm.ask(message.text, role='hryn', context=context)
    if bot_text:
        bot_message = await message.answer(bot_text, reply_to_message_id=message.message_id)
        await save_message(bot_message, bot_addressed=True)


@router.message()
async def unknown_message_handler(message: Message):
    msg_type = "I dont know"

    if message.text:
        msg_type = "text"
    elif message.sticker:
        msg_type = "sticker"
    elif message.photo:
        msg_type = "photo"
    elif message.video:
        msg_type = "video"
    elif message.voice:
        msg_type = "voice"
    elif message.audio:
        msg_type = "audio"
    elif message.document:
        msg_type = "document"
    elif message.contact:
        msg_type = "contact"
    elif message.location:
        msg_type = "location"
    elif message.animation:
        msg_type = "animation"
    elif message.video_note:
        msg_type = "video_note"
    elif message.dice:
        msg_type = "dice"
    elif message.poll:
        msg_type = "poll"
    else:
        msg_type = "unknown"

    logging.info(f"Получено сообщение типа: {msg_type}")
    await save_message(message, type=msg_type)



----------------------------------------

--- D:\Projects\Hryun_bot\handlers\__init__.py ---
# handlers/__init__.py
from aiogram import Dispatcher
from .basic_handlers import rate_limited_router, router

def register_handlers(dp: Dispatcher):
    dp.include_router(rate_limited_router)
    dp.include_router(router)


----------------------------------------

--- D:\Projects\Hryun_bot\middlewares\db.py ---
# \middlewares\db.py
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject
from typing import Callable, Dict, Any, Awaitable
from database import get_db

class DBSessionMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any]
    ) -> Any:
        async with get_db() as db:
            data["db"] = db
            return await handler(event, data)

----------------------------------------

--- D:\Projects\Hryun_bot\middlewares\rate_limit.py ---
# middlewares/rate_limit.py
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject, Message
from typing import Callable, Dict, Any, Awaitable
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

class RateLimitMiddleware(BaseMiddleware):
    def __init__(self, limit: int = 1, period: int = 60):
        self.limit = limit
        self.period = period
        self.user_requests: Dict[int, list] = {}
        super().__init__()

    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any]
    ) -> Any:
        if not isinstance(event, Message):
            logger.debug("Событие не является сообщением, пропускаем rate limit")
            return await handler(event, data)

        user_id = event.from_user.id
        current_time = datetime.now()

        logger.info(f"Проверка rate limit для пользователя {user_id}")

        if user_id in self.user_requests:
            self.user_requests[user_id] = [
                timestamp for timestamp in self.user_requests[user_id]
                if current_time - timestamp < timedelta(seconds=self.period)
            ]
        else:
            self.user_requests[user_id] = []

        if len(self.user_requests[user_id]) >= self.limit:
            logger.info(f"Пользователь {user_id} превысил лимит: {len(self.user_requests[user_id])} запросов")
            await event.answer(
                f"Слишком много запросов! Подождите {self.period} секунд перед следующим запросом."
            )
            return None

        self.user_requests[user_id].append(current_time)
        logger.info(f"Добавлен запрос для {user_id}. Текущие запросы: {self.user_requests[user_id]}")

        return await handler(event, data)
----------------------------------------

--- D:\Projects\Hryun_bot\middlewares\__init__.py ---
# middlewares/__init__.py
from .db import DBSessionMiddleware
from .rate_limit import RateLimitMiddleware
----------------------------------------

--- D:\Projects\Hryun_bot\utils\AI.py ---
# AI.py
import os
from openai import OpenAI
import time
import logging

from config import load_config

config = load_config()

logger = logging.getLogger(__name__)


class LLM:
  def __init__(self):
    self.API_KEY = config.API_KEY
    self.API_URL = config.API_URL
    self.model_gemini_pro_2_5 = config.MODEL_GEMINI_PRO_2_5
    self.model_qwen = config.MODEL_QWEN_2_5
    self.model_deepseek = config.MODEL_DEEPSEEK_V3
    self.model_gemma = config.MODEL_GEMMA_3_27B
    self.model_mistral = config.MODEL_MISTRAL_SMALL_3_1

  def make_client(self):
    return OpenAI(
      base_url=self.API_URL,
      api_key=self.API_KEY,
    )

  @staticmethod
  def get_messages(role, msg):
    # logger.info(f"\nrequests_limit к OpenAI.: {requests_limit}\n")
    if role == 'hryn':
      messages = [
        {"role": "system", "content": config.HRYUN_PROMPT},
        {"role": "user", "content": msg}
      ]
    elif role == 'summary':
      # print(f"\n\nROLE:: {role}\n PROMT:: {summary_prompt}\n CONTENT:: {msg}")
      messages = [
        {"role": "system", "content": config.SUMMARY_PROMPT},
        {"role": "user", "content": msg}
      ]
    else:
      messages = [
        {"role": "system", "content": config.ASSISTANT},
        {"role": "user", "content": msg}
      ]
    return messages

  def ask(self, msg, role='hryn', context=None):
    # logger.info(f"Отправка запроса к OpenAI. Текст: {msg}, Роль: {role}")
    client = self.make_client()

    new_message = LLM.get_messages(role, msg)

    # Формируем список сообщений с историей
    messages = context if context else []  # Берём историю, если есть

    # Добавляем текущее сообщение в контекст
    messages.extend(new_message)
    # print(f"\nMESSAGA:: {messages}\n")
    headers = {
      "HTTP-Referer": "<YOUR_SITE_URL>",
      "X-Title": "<YOUR_SITE_NAME>",
    }

    # models = [self.model_gemini_pro_2_5, self.model_gemma]
    # models = [self.model_gemini_pro_2_5]
    models = [self.model_gemma]
    # models = [self.model_mistral]
    # models = [self.model_deepseek]
    # models = [self.model_qwen]
    max_retries = 3

    for model in models:
      for attempt in range(1, max_retries + 1):
        try:
          logger.info(f"\nСообщения, отправляемые в запрос: {messages}\n")

          completion = client.chat.completions.create(
            extra_headers=headers,
            extra_body={},
            model=model,
            messages=messages
          )
          logger.info(f"Ответ от OpenAI ({model}): {completion}")

          response = completion.choices[0].message.content
          response = response[:4000] if len(response) > 4000 else response

          if response:
            return response
        except Exception as e:
          logger.error(f"Ошибка при запросе к {model} (попытка {attempt}): {e}", exc_info=False)
          if attempt < max_retries:
            time.sleep(11)

    return "Мозги не работают, спроси позже"  # Если все попытки провалились


----------------------------------------

--- D:\Projects\Hryun_bot\utils\history_listing.py ---
# history_listing.py
import asyncio
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from database import get_db, Message, User, Chat


async def get_messages_with_users(tg_chat_id: int, limit: int):
    async with get_db() as session:  # session: AsyncSession
        stmt = (
            select(Message, User)
            .join(User, Message.user_id == User.id)
            .join(Chat, Message.chat_id == Chat.id)  # Явно указываем связь с Chat
            .where(Chat.tg_chat_id == tg_chat_id)  # Фильтр по Telegram ID чата
            .order_by(Message.timestamp.desc())
            .limit(limit)
        )

        result = await session.execute(stmt)
        return result.all()


async def get_history_listing(tg_chat_id: int, limit: int = 100):
    messages = await get_messages_with_users(tg_chat_id, limit)
    if messages:
        summary = []
        async with get_db() as session:
            for chat_message, user in messages:
                username = user.tg_username or "Неизвестный"
                # Обрабатываем разные типы сообщений
                if chat_message.type == "text" or (
                        chat_message.content and chat_message.content not in ["[photo]", "[sticker]", "[video]",
                                                                              "[voice]", "[audio]", "[document]",
                                                                              "[animation]", "[video_note]", "[dice]",
                                                                              "[poll]"]):
                    message_desc = f"сказал: \"{chat_message.content}\""
                else:
                    type_map = {
                        "photo": "отправил фото",
                        "sticker": "отправил стикер",
                        "video": "отправил видео",
                        "voice": "отправил голосовое сообщение",
                        "audio": "отправил аудио",
                        "document": "отправил документ",
                        "animation": "отправил анимацию",
                        "video_note": "отправил видео-кружок",
                        "dice": "бросил кубик",
                        "poll": "создал опрос"
                    }
                    message_desc = type_map.get(chat_message.type, f"отправил что-то странное ({chat_message.type})")

                # Проверяем, является ли сообщение реплаем
                if chat_message.reply_to_tg_message_id:
                    result = await session.execute(
                        select(Message).filter_by(
                            tg_message_id=chat_message.reply_to_tg_message_id,
                            chat_id=chat_message.chat_id
                        )
                    )
                    replied_message = result.scalar_one_or_none()

                    if replied_message:
                        result = await session.execute(
                            select(User).filter_by(id=replied_message.user_id)
                        )
                        replied_user = result.scalar_one_or_none()
                        replied_username = replied_user.tg_username if replied_user and replied_user.tg_username else "Неизвестный"

                        # Обрабатываем тип replied-сообщения
                        if replied_message.type == "text" or (
                                replied_message.content and replied_message.content not in ["[photo]", "[sticker]",
                                                                                            "[video]", "[voice]",
                                                                                            "[audio]", "[document]",
                                                                                            "[animation]",
                                                                                            "[video_note]", "[dice]",
                                                                                            "[poll]"]):
                            # Проверяем content на None перед использованием len()
                            short_text = replied_message.content[:80] + "..." if replied_message.content and len(
                                replied_message.content) > 80 else replied_message.content or "[без текста]"
                            reply_desc = f"сообщение \"{short_text}\""
                        else:
                            reply_desc = type_map.get(replied_message.type, f"что-то странное ({replied_message.type})")

                        summary.append(
                            f"{chat_message.timestamp} юзер '{username}' ответил \"{chat_message.content}\" на {reply_desc} от юзера '{replied_username}'"
                        )
                    else:
                        print("⚠️ Ошибка: Не найдено сообщение, на которое идет ответ!")
                        summary.append(
                            f"{chat_message.timestamp} юзер '{username}' ответил \"{chat_message.content}\" на неизвестное сообщение"
                        )
                else:
                    summary.append(
                        f"{chat_message.timestamp} юзер '{username}' {message_desc}"
                    )
            summary.reverse()
            return "\n".join(summary)
    else:
        return "В этом чате пока нет сообщений для отчета."


async def main():
    content = await get_history_listing(tg_chat_id=-1002619036043, limit=16)
    print(content)


if __name__ == "__main__":
    asyncio.run(main())
----------------------------------------

--- D:\Projects\Hryun_bot\utils\lock.py ---
# utils\lock.py
from asyncio import Lock


class ChatLocks:
    _locks: dict[int, Lock] = {}

    @classmethod
    def get_lock(cls, chat_id: int) -> Lock:
        if chat_id not in cls._locks:
            cls._locks[chat_id] = Lock()
        return cls._locks[chat_id]


----------------------------------------

--- D:\Projects\Hryun_bot\utils\message_thread.py ---
# utils\message_thread.py
import logging
import random
import yaml
import os
from sqlalchemy.future import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload
from sqlalchemy import or_
from sqlalchemy import select, insert, delete, exists
from sqlalchemy.exc import SQLAlchemyError

from database import get_db, Message, User, Chat, UsedAnekdot
from config import load_config

config = load_config()
ANEKDOTS_FILE = config.ANEKDOTS_FILE


async def get_message_thread(db: AsyncSession, tg_user_id: int, tg_chat_id: int, limit: int=20, **kwargs):
    """ Строит цепочку сообщений в заданном чате между юзером и ботом по реплаям и по признаку bot_addressed=True
        (значит сообщение адресовано или принадлежит боту).
        Возвращает словарь для создания контекста для OpenAI.
    """
    async with (db.begin()):
        # Находим пользователя и чат
        user_result = await db.execute(
            select(User).filter_by(tg_user_id=tg_user_id)
        )
        user = user_result.scalar_one_or_none()
        if not user:
            return []
            # return {"error": "Пользователь не найден"}

        chat_result = await db.execute(
            select(Chat).filter_by(tg_chat_id=tg_chat_id)
        )
        chat = chat_result.scalar_one_or_none()
        if not chat:
            # return {"error": "Чат не найден"}
            return []

        # Получаем все сообщения в чате с bot_addressed=True, связанные с пользователем или ботом
        stmt = (
            select(Message, User)
            .join(User, Message.user_id == User.id)
            .where(
                Message.chat_id == chat.id,
                Message.bot_addressed == True
            )
            .order_by(Message.timestamp.asc())
        )
        result = await db.execute(stmt)
        messages = result.all()

        if not messages:
            # return {"messages": [], "context": "Нет сообщений в цепочке"}
            return []

        # Строим цепочку сообщений на основе reply_to_tg_message_id
        message_dict = {msg.tg_message_id: (msg, usr) for msg, usr in messages}
        thread = []
        seen_messages = set()

        def build_thread(current_msg_id):
            if current_msg_id in seen_messages:
                return  # Предотвращаем зацикливание
            if current_msg_id not in message_dict:
                return  # Сообщение не найдено или не входит в bot_addressed

            msg, usr = message_dict[current_msg_id]
            seen_messages.add(current_msg_id)
            thread_entry = {
                "user": usr.tg_username or usr.tg_first_name,
                "content": msg.content or f"[{msg.type}]"
            }

            # Если есть сообщение, на которое это ответ
            if msg.reply_to_tg_message_id:
                build_thread(msg.reply_to_tg_message_id)
                thread.append(thread_entry)
            else:
                thread.append(thread_entry)

        # Начинаем с последнего сообщения пользователя, если указано конкретное сообщение
        start_message_id = kwargs.get("start_tg_message_id")
        if start_message_id and start_message_id in message_dict:
            build_thread(start_message_id)
        else:
            # Иначе берем все сообщения и строим полную цепочку
            for msg_id in message_dict:
                if msg_id not in seen_messages:
                    build_thread(msg_id)

        # Формируем текстовый контекст для OpenAI
        context = []
        for entry in thread:
            strip = {}
            role = "assistant" if entry["user"] == "hryun2_bot" else "user"
            strip["role"] = role
            strip["content"] = entry['content']
            context.append(strip)
        return context[-limit:]


# Тестовая функция для запуска get_message_thread
async def main():
    async with get_db() as db:
        thread = await get_message_thread(db=db, tg_user_id=1585006634, tg_chat_id=-1002619036043, limit=5)

        print("Результат get_message_thread:")
        for i in thread:
            print(i)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
----------------------------------------

--- D:\Projects\Hryun_bot\utils\services.py ---
# utils\services.py
import logging
import random
import yaml
import os
import asyncio
import time
from functools import wraps
from aiogram.types import Message
# from aiogram.exceptions import Throttled

from sqlalchemy.future import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload
from sqlalchemy import or_
from sqlalchemy import select, insert, delete, exists
from sqlalchemy.exc import SQLAlchemyError

from database import get_db, Message, User, Chat, UsedAnekdot
from config import load_config

config = load_config()
ANEKDOTS_FILE = config.ANEKDOTS_FILE


async def get_or_create_user(db: AsyncSession, tg_user_id: int, **kwargs):
    async with db.begin():
        result = await db.execute(
            select(User).filter_by(tg_user_id=tg_user_id)
        )
        user = result.scalar_one_or_none()
        if not user:
            user = User(tg_user_id=tg_user_id, **kwargs)
            db.add(user)
            await db.commit()
        return user


async def get_or_create_chat(db: AsyncSession, tg_chat_id: int, title=None):
    async with db.begin():
        result = await db.execute(
            select(Chat).filter_by(tg_chat_id=tg_chat_id)
        )
        chat = result.scalar_one_or_none()
        if not chat:
            chat = Chat(tg_chat_id=tg_chat_id, title=title)
            db.add(chat)
            await db.commit()
        return chat


async def save_message(message, bot_addressed=False, type="None type"):
    tg_chat_id = message.chat.id
    tg_user_id = message.from_user.id
    tg_username = message.from_user.username or ""
    tg_first_name = message.from_user.first_name  # Имя пользователя
    tg_last_name = message.from_user.last_name or ""  # Фамилия (может быть пустой)
    chat_title = message.chat.title if message.chat.title else f"Личный чат с {tg_first_name}"
    tg_message_id = message.message_id
    message_content = message.text if message.text else None
    type = type
    reply_to_tg_message_id = message.reply_to_message.message_id if message.reply_to_message else None

    try:
        async with get_db() as db:
            # Получаем или создаем чат
            chat = await get_or_create_chat(db, tg_chat_id, title=chat_title)

            # Получаем или создаем пользователя
            user = await get_or_create_user(db, tg_user_id, tg_username=tg_username, tg_first_name=tg_first_name,
                                            tg_last_name=tg_last_name)

            # Если сообщение является реплаем, ищем его в БД
            reply_to_message = None
            if reply_to_tg_message_id:
                result = await db.execute(
                    select(Message).filter_by(tg_message_id=reply_to_tg_message_id, chat_id=chat.id)
                )
                reply_to_message = result.scalar_one_or_none()

            # Сохраняем сообщение
            new_message = Message(
                tg_message_id=tg_message_id,
                chat_id=chat.id,
                user_id=user.id,
                content=message_content,
                bot_addressed=bot_addressed,
                type=type,
                reply_to_tg_message_id=reply_to_message.tg_message_id if reply_to_message else None
            )
            db.add(new_message)
            await db.commit()

    except Exception as e:
        logging.error(f"Ошибка при сохранении сообщения: {e}", exc_info=True)
        await db.rollback()  # Откат изменений при ошибке


async def get_anekdot():
    # Загружаем анекдоты из файла
    with open(ANEKDOTS_FILE, "r", encoding="utf-8") as f:
        anekdots = yaml.safe_load(f)
    all_keys = list(anekdots.keys())

    async with get_db() as db:
        try:
            # Получаем использованные ключи из таблицы UsedAnekdot
            result = await db.execute(select(UsedAnekdot.anekdot_key))
            used_keys = [row[0] for row in result.fetchall()]

            # Если все анекдоты использованы — очищаем таблицу
            if len(used_keys) >= len(all_keys):
                await db.execute(delete(UsedAnekdot))
                await db.commit()
                used_keys = []

            # Находим доступные ключи и выбираем случайный
            available_keys = list(set(all_keys) - set(used_keys))
            if not available_keys:
                raise ValueError("Нет доступных анекдотов")

            random_key = random.choice(available_keys)

            # Добавляем использованный ключ в таблицу
            stmt = insert(UsedAnekdot).values(anekdot_key=random_key)
            await db.execute(stmt)
            await db.commit()

            return f"Ане́кдот №{random_key}:\n\n{anekdots[random_key]}"

        except SQLAlchemyError as e:
            logging.error(f"Ошибка при работе с базой данных: {e}", exc_info=True)
            await db.rollback()
        except Exception as e:
            logging.error(f"Ошибка при получении анекдота: {e}", exc_info=True)




----------------------------------------

--- D:\Projects\Hryun_bot\utils\__init__.py ---

----------------------------------------

